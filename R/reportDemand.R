#' Read in GDX and calculate (net and gross) annual demand, used in convGDX2MIF.R for the reporting
#'
#' Read in (net and gross) demand data from GDX file, information used in convGDX2MIF.R
#' for the reporting
#'
#' @param gdx a GDX object as created by readGDX, or the path to a gdx
#' @param output a magpie object containing all needed variables generated by other report*.R functions
#' @param reporting_tau boolean determining whether to provide the generation
#'  reporting at the time slice level (TRUE) or at the yearly level (FALSE, default)
#' @return MAgPIE object - contains the capacity variables
#' @author Sebastian Osorio, Renato Rodrigues
#' @seealso \code{\link{convGDX2MIF}}
#' @examples
#' \dontrun{
#' reportDemand(gdx, output = NULL)
#' }
#'
#' @importFrom gdx readGDX
#' @importFrom magclass mbind setNames dimSums getSets getSets<- as.magpie getItems collapseDim
#' @export
#'
reportDemand <- function(gdx, output = NULL, reporting_tau = FALSE) {

  if (is.null(output) && !reporting_tau) {
    stop("argument `output` is NULL. Please provide a file containing all needed information")
  }

  # Loading parameters from convGDX2MIF parent function
  c_demandscale <- readGDX(gdx, name = "c_demandscale", field = "l", format = "first_found") # factor for scaling net demand
  c_LIMESversion <- readGDX(gdx, name = "c_LIMESversion", field = "l", format = "first_found")
  tau <- readGDX(gdx, name = "tau") # set of time slices
  te <- readGDX(gdx, name = "te") # set of technologies

  # Loading parameters and variables
  p_taulength <- readGDX(gdx, name = c("p_taulength", "pm_taulength"), field = "l", format = "first_found", restore_zeros = FALSE)[, , tau] # number of hours/year per tau
  v_exdemand <- readGDX(gdx, name = "v_exdemand", field = "l", format = "first_found", restore_zeros = FALSE) # demand

  # Make sure only the "right" tau are taken -> to avoid info from gdx that might be stuck in the file
  v_exdemand <- v_exdemand[, , tau]
  p_taulength <- p_taulength[, , tau]

  # create MagPie object of demand with iso3 regions
  v_exdemand <- limesMapping(v_exdemand)
  p_hedemand <- new.magpie(cells_and_regions = getItems(v_exdemand, dim = 1), years = getYears(v_exdemand), names = tau,
                           fill = NA, sort = FALSE, sets = NULL)
  p_DH_losses <- new.magpie(cells_and_regions = getItems(v_exdemand, dim = 1), years = NULL, names = NULL,
                            fill = NA, sort = FALSE, sets = NULL)
  p_etah <- new.magpie(cells_and_regions = getItems(v_exdemand, dim = 1), years = NULL, names = te,
                       fill = NA, sort = FALSE, sets = NULL)

  # Check the version so to choose the electricity-related variables
  if (c_LIMESversion >= 2.28) {
    heating <- .readHeatingCfg(gdx)
    if (heating == "fullDH") {
      p_eldemand <- v_exdemand[, , "seel"]
      p_hedemand <- v_exdemand[, , "sehe"] # This contains all heat production covered (directly or indirectly) by EU ETS (i.e., DH and decentraliced electric-based heating)
      p_hedemand <- collapseDim(p_hedemand, dim = 3.2)

      p_DH_losses <- readGDX(gdx, name = "p_DH_losses", field = "l", format = "first_found")
      p_DH_losses <- limesMapping(p_DH_losses)

      p_tedata <- readGDX(gdx, name = "p_tedata", field = "l", format = "first_found")
      p_etah <- p_tedata[, , "etah"]
      p_etah <- limesMapping(p_etah)

    } else {
      p_eldemand <- v_exdemand
    }
  } else {
    p_eldemand <- v_exdemand

  }

  # Collapse names of demand (just in case)
  p_eldemand <- collapseDim(p_eldemand, dim = 3.2)

  #Years
  y <- getYears(p_eldemand)

  # Standard Reporting ------------------------------------------------------
  if (!reporting_tau) { # for normal reporting

    # electricity-related
    tmp1 <- NULL

    # Peak demand
    tmp1 <- mbind(tmp1, setNames(as.magpie(apply(p_eldemand, 1:2, max)), "Capacity|Electricity|Peak Demand (GW)"))

    #Electricity demand in this case comprises all consumption
    tmp1 <- mbind(tmp1, setNames(dimSums(p_eldemand * p_taulength / c_demandscale, dim = 3) / 1000, "Final Energy|Electricity (TWh/yr)"))
    tmp1 <- mbind(tmp1, setNames(dimSums(p_eldemand * p_taulength / c_demandscale, dim = 3) * (c_demandscale - 1) / 1000, "Final Energy|Electricity|Losses (TWh/yr)"))

    if(c_LIMESversion >= 2.38) {
      #Use of electricity for transport
      p_exdem_trans <- readGDX(gdx, name = "p_exdem_trans", field = "l", format = "first_found")[,y,]
      p_exdem_trans <- limesMapping(p_exdem_trans)
      tmp1 <- mbind(tmp1, setNames(dimSums(p_exdem_trans * p_taulength, dim = 3) / 1000, "Secondary Energy Input|Electricity|Transport (TWh/yr)"))

      #Use of electricity for Hydrogen production
      tmp1 <- mbind(tmp1, setNames(output[,, "Primary Energy|Electricity|Hydrogen (TWh/yr)"], "Secondary Energy Input|Electricity|Hydrogen (TWh/yr)"))
    }


    # heating-related
    tmp2 <- NULL
    if (c_LIMESversion >= 2.28) {
      if (heating == "fullDH") {

        # Heat-related
        v_heatwaste <- readGDX(gdx, name = "v_heatwaste", field = "l", format = "first_found") # Waste heat
        v_heatwaste <- limesMapping(v_heatwaste)

        tmp2 <- mbind(tmp2, setNames(dimSums(v_heatwaste * p_taulength, dim = 3) / 1000, "Useful Energy|Heat waste (TWh/yr)"))

        c_buildings <- readGDX(gdx, name = c("c_buildings", "report_c_buildings"),
                               field = "l", format = "first_found") #switch on buildings module

        #Peak demand
        if(c_buildings == 1) {
          p_bd_peakdemand <- readGDX(gdx, name = c("p_bd_peakdemand"), field = "l", format = "first_found", react = 'silent') #heat peak demand in buildings
          p_bd_peakdemand <- limesMapping(p_bd_peakdemand)[ ,y,"sehe"]
          tmp2 <- mbind(tmp2, setNames(p_bd_peakdemand, "Useful Energy|Heat|Buildings|Peak Demand (GW)"))
        }

        #Electricity peak demand due to P2H
        o_PeakDemP2H <- readGDX(gdx, name = "o_PeakDemP2H", field = "l", format = "first_found", react = 'silent') #electricity peak demand from P2H

        if(!is.null(o_PeakDemP2H)) {
          o_PeakDemP2H <- limesMapping(o_PeakDemP2H)[ ,y,"seel"]
          tmp2 <- mbind(tmp2, setNames(o_PeakDemP2H, "Capacity|Electricity|Peak Demand|Power to heat (GW)"))

          o_demP2H_PeakElec <- readGDX(gdx, name = c("o_demP2H_PeakElec"), field = "l", format = "first_found", react = 'silent') #P2H  demand when peak
          o_demP2H_PeakElec <- limesMapping(o_demP2H_PeakElec)[ ,y,"seel"]
          tmp2 <- mbind(tmp2, setNames(o_demP2H_PeakElec, "Capacity|Electricity|Power to heat when peak demand (GW)"))
        }


      }
    }

    # concatenating net and gross demand data
    tmp <- mbind(tmp1, tmp2)

  } else { #if not the reportTau
    # TAU reporting -----------------------------------------------------------

    rename_tau <- function(name, data) {
      .tau_nb <- getNames(data)
      .nm <- paste0(name, "|", .tau_nb, " (GW)")
      out <- setNames(data, .nm)
      return(out)
    }

    tmp <- rename_tau("Demand Load|Electricity", p_eldemand)

    if (heating == "fullDH") {
    tmp <- mbind(tmp,
                 rename_tau("Demand Load|Heat", p_hedemand)
                 )
    }
  }

  return(tmp)
}
