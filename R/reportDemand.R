#' Read in GDX and calculate (net and gross) annual demand, used in convGDX2MIF.R for the reporting
#'
#' Read in (net and gross) demand data from GDX file, information used in convGDX2MIF.R
#' for the reporting
#'
#' @param gdx a GDX object as created by readGDX, or the path to a gdx
#' @param output a magpie object containing all needed variables generated by other report*.R functions
#' @return MAgPIE object - contains the capacity variables
#' @author Sebastian Osorio, Renato Rodrigues
#' @seealso \code{\link{convGDX2MIF}}
#' @examples
#' \dontrun{
#' reportDemand(gdx, output = NULL)
#' }
#'
#' @importFrom gdx readGDX
#' @importFrom magclass mbind setNames dimSums getSets getSets<- as.magpie getItems collapseDim
#' @export
#'
reportDemand <- function(gdx, output = NULL) {

  if (is.null(output)) {
    stop("please provide a file containing all needed information")
  }

  # Loading parameters from convGDX2MIF parent function
  c_demandscale <- readGDX(gdx, name = "c_demandscale", field = "l", format = "first_found") # factor for scaling net demand
  c_LIMESversion <- readGDX(gdx, name = "c_LIMESversion", field = "l", format = "first_found")
  tau <- readGDX(gdx, name = "tau") # set of time slices
  te <- readGDX(gdx, name = "te") # set of technologies

  # Loading parameters and variables
  p_taulength <- readGDX(gdx, name = c("p_taulength", "pm_taulength"), field = "l", format = "first_found", restore_zeros = FALSE)[, , tau] # number of hours/year per tau
  v_exdemand <- readGDX(gdx, name = "v_exdemand", field = "l", format = "first_found", restore_zeros = FALSE) # demand

  # Make sure only the "right" tau are taken -> to avoid info from gdx that might be stuck in the file
  v_exdemand <- v_exdemand[, , tau]
  p_taulength <- p_taulength[, , tau]

  # create MagPie object of demand with iso3 regions
  v_exdemand <- limesMapping(v_exdemand)
  p_hedemand <- new.magpie(cells_and_regions = getItems(v_exdemand, dim = 1), years = getYears(v_exdemand), names = tau,
                           fill = NA, sort = FALSE, sets = NULL, unit = "unknown")
  o_elecheat <- new.magpie(cells_and_regions = getItems(v_exdemand, dim = 1), years = getYears(v_exdemand), names = NULL,
                           fill = 0, sort = FALSE, sets = NULL, unit = "unknown")
  p_DH_losses <- new.magpie(cells_and_regions = getItems(v_exdemand, dim = 1), years = NULL, names = NULL,
                           fill = NA, sort = FALSE, sets = NULL, unit = "unknown")
  p_etah <- new.magpie(cells_and_regions = getItems(v_exdemand, dim = 1), years = NULL, names = te,
                       fill = NA, sort = FALSE, sets = NULL, unit = "unknown")

  # Check the version so to choose the electricity-related variables
  if (c_LIMESversion >= 2.28) {
    c_heating <- readGDX(gdx, name = "c_heating", field = "l", format = "first_found")
    if (c_heating == 1) {
      p_eldemand <- v_exdemand[, , "seel"]
      p_hedemand <- v_exdemand[, , "sehe"] # This contains all heat production covered (directly or indirectly) by EU ETS (i.e., DH and decentraliced electric-based heating)
      p_hedemand <- collapseDim(p_hedemand, dim = 3.2)

      p_DH_losses <- readGDX(gdx, name = "p_DH_losses", field = "l", format = "first_found")
      p_DH_losses <- limesMapping(p_DH_losses)

      p_tedata <- readGDX(gdx, name = "p_tedata", field = "l", format = "first_found")
      p_etah <- p_tedata[, , "etah"]
      p_etah <- limesMapping(p_etah)

    } else {
      p_eldemand <- v_exdemand
    }
  } else {
    p_eldemand <- v_exdemand

  }

  # Collapse names of demand (just in case)
  p_eldemand <- collapseDim(p_eldemand, dim = 3.2)

  # Load also the storage consumption
  o_storecons <- output[, , "Secondary Energy|Electricity|Storage Consumption (TWh/yr)"]
  getNames(o_storecons) <- NULL

  # electricity-related
  tmp1 <- NULL

  # Peak demand countries
  tmp1 <- mbind(tmp1, setNames(as.magpie(apply(p_eldemand, 1:2, max)), "Capacity|Electricity|Peak Demand (GW)"))

  #Electricity demand in this case comprises all consumption
  tmp1 <- mbind(tmp1, setNames(dimSums(p_eldemand * p_taulength / c_demandscale, dim = 3) / 1000, "Final Energy|Electricity (TWh/yr)"))

  if(c_LIMESversion >= 2.38) {
    #Use of electricity for transport
    p_exdem_trans <- readGDX(gdx, name = "p_exdem_trans", field = "l", format = "first_found")
    p_exdem_trans <- limesMapping(p_exdem_trans)
    tmp1 <- mbind(tmp1, setNames(dimSums(p_exdem_trans * p_taulength, dim = 3) / 1000, "Secondary Energy Input|Electricity|Transport (TWh/yr)"))

    #Use of electricity for Hydrogen production
    tmp1 <- mbind(tmp1, setNames(output[,, "Primary Energy|Electricity|Hydrogen (TWh/yr)"], "Secondary Energy Input|Electricity|Hydrogen (TWh/yr)"))
  }


  # heating-related
  tmp2 <- NULL
  if (c_LIMESversion >= 2.28) {
    if (c_heating == 1) {

      # Heat-related
      c_buildings <- readGDX(gdx, name = "c_buildings", field = "l", format = "first_found") # switch on buildings module
      v_heatwaste <- readGDX(gdx, name = "v_heatwaste", field = "l", format = "first_found") # Waste heat
      v_heatwaste <- limesMapping(v_heatwaste)

      tmp2 <- mbind(tmp2, setNames(dimSums(v_heatwaste * p_taulength, dim = 3) / 1000, "Useful Energy|Heat waste (TWh/yr)"))
      # tmp2 <- mbind(tmp2,setNames(dimSums(p_hedemand*p_taulength,dim=3)/(1+p_DH_losses))/1000,"Final Energy|Heat (TWh/yr)")



      if (c_buildings == 0) {



      } else if(c_LIMESversion >= 2.38 & c_buildings == 1) {
        ## Use of electricity in heating
        #tmp2 <- mbind(tmp2, setNames(dimSums(p_eldemand * p_taulength / c_demandscale, dim = 3) / 1000, "Final Energy|Electricity [w/o Hydrogen production] (TWh/yr)"))
        #tmp2 <- mbind(tmp2, setNames(
        #  tmp2[,,"Final Energy|Electricity [w/o Hydrogen production] (TWh/yr)"] + output[,,"Secondary Energy|Electricity|Storage Consumption|Hydrogen electrolysis (TWh/yr)"],
        #  "Final Energy|Electricity (TWh/yr)"))


        ##Use of electricity for cooling
        #p_exdem_cool <- readGDX(gdx, name = "p_exdem_cool", field = "l", format = "first_found")
        #p_exdem_cool <- limesMapping(p_exdem_cool)
        #tmp2 <- mbind(tmp2, setNames(dimSums(dimSums(p_exdem_cool, dim = 3.2) * p_taulength, dim = 3) / 1000, "Secondary Energy Input|Electricity|Cooling (TWh/yr)"))




      }
    }
  }

  # concatenating net and gross demand data
  tmp <- mbind(tmp1, tmp2)

  return(tmp)
}
