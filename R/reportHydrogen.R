#' Read in GDX and calculate different variables related to hydrogen production and trade
#' , including also prices, used in convGDX2MIF.R for the reporting
#'
#' Read in hydrogen-related data from GDX file, information used in convGDX2MIF.R
#' for the reporting
#'
#'
#' @param gdx a GDX object as created by readGDX, or the path to a gdx
#' @param output a magpie object containing all needed variables generated by other report*.R functions
#'  reporting at the time slice level (TRUE) or at the yearly level (FALSE, default)
#' @return MAgPIE object - contains the Generation variables
#' @author Sebastian Osorio
#' @seealso \code{\link{convGDX2MIF}}
#' @examples
#' \dontrun{
#' reportHydrogen(gdx)
#' }
#'
#' @importFrom gdx readGDX
#' @importFrom magclass mbind setNames dimSums as.magpie getItems collapseDim
#' @export
#'
reportHydrogen <- function(gdx, output = NULL) {

  if(is.null(output)) {
    stop("argument `output` is NULL. Please provide a file containing all needed information")
  }

  #Read sets
  tt <- readGDX(gdx, name = "t", field = "l", format = "first_found") # time set
  t0 <- tt[1]
  tau <- readGDX(gdx, name = "tau") # set of time slices

  #Read parameters
  c_esmdisrate <- readGDX(gdx, name = "c_esmdisrate", field = "l", format = "first_found") # interest rate
  p_ts <- readGDX(gdx, name = "p_ts", field = "l", format = "first_found") # time-step
  p_taulength <- readGDX(gdx, name = c("p_taulength", "pm_taulength"),
                         field = "l", format = "first_found")[, , tau] # number of hours/year per tau
  c_LIMESversion <- readGDX(gdx, name = "c_LIMESversion", field = "l", format = "first_found")

  # compute factor to discount average marginal values
  f_npv <- as.numeric(p_ts) * exp(-as.numeric(c_esmdisrate) * (as.numeric(tt) - as.numeric(t0)))

  tmp<-NULL

  # Hydrogen module only exists as of version 2.36, but first version is quite different from the rest
  if(c_LIMESversion >= 2.36) {

    ########################################################
    ##PRODUCTION

    tmp1<-NULL

    #Hydrogen produced from electricity (electrolysis input - losses)
    v_prodP2XSe <- readGDX(gdx, name = c("v_otherse", "v_prodP2XSe"), field = "l",
                           format = "first_found", react = 'silent',
                           restore_zeros = FALSE)[, , "pehgen"] # [GWh]
    v_prodP2XSe <- limesMapping(v_prodP2XSe[, , tau])

    #Reported under two different names
    tmp1 <- mbind(tmp1, setNames(dimSums(p_taulength * v_prodP2XSe, 3) / 1000,
                                 "Secondary Energy|Hydrogen|Electricity (TWh/yr)"))
    tmp1 <- mbind(tmp1, setNames(setNames(tmp1[, , "Secondary Energy|Hydrogen|Electricity (TWh/yr)"], NULL),
                                 "Primary Energy|Hydrogen [electrolysis] (TWh/yr)"))


    ########################################################
    ##DEMAND

    #First version quite different from the others
    #Hydrogen from external sources used in electricity production
    #(from version 2.37 there is the option of external demand of H2,
    #so it is not possible to know anymore if the imported H2 is exclusively used for electricity production)
    if (c_LIMESversion == 2.36) {

      # Read additional variables only available after this model version
      tehgen <- readGDX(gdx, name = "tehgen")
      v_p2xse <- readGDX(gdx, name = c("v_p2xse", "v_demP2XSe_4el"), field = "l",
                         format = "first_found", restore_zeros = FALSE) # [GWh]
      v_p2xse <- limesMapping(v_p2xse[, , tau])
      v_p2xse <- v_p2xse[, , tau]

      # Because of some tests in v2.36, there might be some runs in which some variables might be renamed to the names used in 2.37
      if (length(grep("hcc", getNames(v_p2xse))) > 0) {
        if (length(grep("pehgen.seel", getNames(v_p2xse))) > 0) {
          v_p2xse <- v_p2xse[, , "pehgen.seel"]
        }
        v_p2xse <- v_p2xse[, , tehgen]

        varList_hgen <- list(
          "Primary Energy|Hydrogen [electrolysis]|Electricity (TWh/yr)"               = c(tehgen),
          "Primary Energy|Hydrogen [electrolysis]|Electricity|Hydrogen FC (TWh/yr)" = "hfc",
          "Primary Energy|Hydrogen [electrolysis]|Electricity|Hydrogen OC (TWh/yr)" = "hct",
          "Primary Energy|Hydrogen [electrolysis]|Electricity|Hydrogen CC (TWh/yr)" = "hcc"
        )

        for (var in names(varList_hgen)) {
          tmp1 <- mbind(tmp1, setNames(dimSums(dimSums(
            v_p2xse[, , varList_hgen[[var]]], dim = c(3.2)) * p_taulength, dim = 3) /
              1000, var))
        }

      } else {

        tmp1 <- mbind(tmp1, setNames(dimSums(v_p2xse[, , ] * p_taulength, dim = 3) / 1000,
                                     "Primary Energy|Hydrogen [electrolysis]|Electricity (TWh/yr)"))
      }

      # Hydrogen produced by electrolysis and used to generate electricity
      o_hgen_ext_el <- pmax(setNames(output[, , "Primary Energy|Hydrogen|Electricity (TWh/yr)"], NULL) -
                              setNames(tmp1[, , "Secondary Energy|Hydrogen|Electricity (TWh/yr)"], NULL), 0)
      tmp1 <- mbind(tmp1, setNames(o_hgen_ext_el, "Primary Energy|Hydrogen [external]|Electricity (TWh/yr)"))


      #End of if c_LIMESversion == 2.36
    }

    #After version >= 2.37, demand representation does not change substantially
    if (c_LIMESversion >= 2.37) {

      # Hydrogen sold to other sectors (i.e., not used for electricity generation) - exogenous
      p_demXSe_exo <- readGDX(gdx, name = c("p_demXSe_exo"), field = "l", format = "first_found",
                              restore_zeros = TRUE) # [GWh]
      p_demXSe_exo <- limesMapping(p_demXSe_exo[, getYears(output), "pehgen"])

      #Endogenous demand from industry
      o_FuelConsSector_Industry <- readGDX(gdx, name = c("o_FuelConsSector_Industry"),
                                           field = "l", format = "first_found",
                                           restore_zeros = T, react = 'silent') # [GWh]
      if(!is.null(o_FuelConsSector_Industry)) {
        o_FuelConsSector_Industry <- limesMapping(o_FuelConsSector_Industry)
        o_H2ConsSector_Industry <- o_FuelConsSector_Industry[, , "pehgen"]
      } else {
        o_H2ConsSector_Industry <- new.magpie(cells_and_regions = getItems(output, dim = 1),
                                              years = getYears(output), names = NULL,
                                              fill = 0, sort = FALSE, sets = NULL)
      }

      #Report
      tmp1 <- mbind(tmp1, setNames(
        (collapseDim(p_demXSe_exo) + collapseDim(o_H2ConsSector_Industry)) / 1000,
        "Final Energy|Hydrogen|Other sectors (TWh/yr)"))
      tmp1 <- mbind(tmp1, setNames(output[,, "Primary Energy|Hydrogen|Electricity (TWh/yr)"],
                                   "Final Energy|Hydrogen|Power Sector (TWh/yr)"))
      tmp1 <- mbind(tmp1, setNames(
        setNames(tmp1[,, "Final Energy|Hydrogen|Other sectors (TWh/yr)"], NULL) +
          setNames(tmp1[,, "Final Energy|Hydrogen|Power Sector (TWh/yr)"], NULL),
        "Final Energy|Hydrogen (TWh/yr)"))

    }


    ########################################################
    ##TRADE / IMPORTS

    # Hydrogen could be produced internally (electrolysis) or
    #externally (imported at fixed price) and used in the power sector or in other sectors,
    #without specifying the exact supply chain,
    #e.g., not clear whether hydrogen produced from electrolysis is used in electricity generation
    if(c_LIMESversion >= 2.37 & c_LIMESversion <= 2.40) {

      ## External hydrogen, i.e., imported hydrogen (H2 demand - H2 produced by electrolysers)
      c_sharehgen <- readGDX(gdx, name = "c_sharehgen", field = "l", format = "first_found")
      if (c_sharehgen == 1) {
        v_imp_XSe_4el <- new.magpie(cells_and_regions = getItems(v_prodP2XSe, dim = 1),
                                    years = getYears(v_prodP2XSe), names = NULL,
                                    fill = 0, sort = FALSE, sets = NULL)
        v_imp_XSe_4nel <- new.magpie(cells_and_regions = getItems(v_prodP2XSe, dim = 1),
                                     years = getYears(v_prodP2XSe), names = NULL,
                                     fill = 0, sort = FALSE, sets = NULL)
      } else {
        v_imp_XSe_4el <- readGDX(gdx, name = c("v_imp_XSe_4el","v_imp_XSe_4el_tau"),
                                 field = "l", format = "first_found", restore_zeros = FALSE)[, , "pehgen"] # [GWh]
        v_imp_XSe_4el <- limesMapping(v_imp_XSe_4el)

        v_imp_XSe_4nel <- readGDX(gdx, name = "v_imp_XSe_4nel", field = "l", format = "first_found",
                                  restore_zeros = FALSE)[, , "pehgen"] # [GWh]
        v_imp_XSe_4nel <- limesMapping(v_imp_XSe_4nel)
      }

      tmp1 <- mbind(tmp1, setNames((v_imp_XSe_4el + v_imp_XSe_4nel) / 1000,
                                   "Primary Energy|Hydrogen [external] (TWh/yr)"))

      #Hydrogen imports
      tmp1 <- mbind(tmp1, setNames(
        setNames(tmp1[,, "Final Energy|Hydrogen (TWh/yr)"], NULL) -
          setNames(tmp1[,, "Primary Energy|Hydrogen [electrolysis] (TWh/yr)"], NULL),
        "Net imports|Hydrogen (TWh/yr)"))

      #End of if c_LIMESversion >= 2.37 & c_LIMESversion <= 2.40
    }

    #In version >= 2.41, we do not represent the entire H2 network but we allow for trade
    #This means that there we distinguish imports from the internal marker and from abroad
    #However, there are multiple solutions and it does not make sense to distinguish between them
    if (c_LIMESversion >= 2.41) {

      #net imports from internal market
      v_NetImpInMarket_XSe <- readGDX(gdx, name = c("v_NetImpInMarket_XSe"),
                               field = "l", format = "first_found", restore_zeros = FALSE)[, , "pehgen"] # [GWh]
      v_NetImpInMarket_XSe <- limesMapping(v_NetImpInMarket_XSe)
      #net imports from external market
      v_ImpAbroad_XSe <- readGDX(gdx, name = c("v_ImpAbroad_XSe"),
                                 field = "l", format = "first_found", restore_zeros = FALSE)[, , "pehgen"] # [GWh]
      v_ImpAbroad_XSe <- limesMapping(v_ImpAbroad_XSe)

      #report
      tmp1 <- mbind(tmp1, setNames((v_NetImpInMarket_XSe + v_ImpAbroad_XSe) / 1000,
                                   "Net imports|Hydrogen (TWh/yr)"))
      tmp1 <- mbind(tmp1, setNames(pmax(v_NetImpInMarket_XSe + v_ImpAbroad_XSe, 0) / 1000,
                                   "Primary Energy|Hydrogen [external] (TWh/yr)"))

    } #end if c_LIMESversion >= 2.41


    # Total hydrogen used in the model
    if(c_LIMESversion >= 2.37) {

      tmp1 <- mbind(tmp1, setNames(
        setNames(tmp1[,, "Primary Energy|Hydrogen [electrolysis] (TWh/yr)"], NULL) +
          setNames(tmp1[,, "Primary Energy|Hydrogen [external] (TWh/yr)"], NULL),
        "Primary Energy|Hydrogen (TWh/yr)"))
    }


    #######################################################
    ##PRICES: marginal production cost from electrolysers

    # Marginal production cost for hydrogen
    #In previous versions there were different equations for the H2 balance, and then different marginals
    #In most recent version, there is only one
    #Create data frame to save the information
    m_p2x_year <- new.magpie(cells_and_regions = getItems(v_prodP2XSe, dim = 1),
                             years = getYears(v_prodP2XSe), names = NULL,
                             fill = NA, sort = FALSE, sets = NULL)

    #Former formulation is too messy, so better to have the recent (clean one) below
    #but ensure that previous versions still work
    if(c_LIMESversion <= 2.40) {
      #When there is no H2 exchange (constraint at national level)
      m_p2x_regi <- readGDX(gdx, name = c("q_p2x", "q_balP2XSe","q_aggdemXSE_el_year"),
                            field = "m", format = "first_found", restore_zeros = FALSE,
                            react = 'silent') # [Geur/GWh]
      if(!is.null(getItems(m_p2x_regi, dim = 1))) { #this checks if the equation is active
        m_p2x_regi <- limesMapping(m_p2x_regi[, , "pehgen"])

        if (length(grep("1", getNames(m_p2x_regi))) > 0) { # In some versions q_p2x is tau-dependent
          m_p2x_regi <- m_p2x_regi[, , tau] / p_taulength
          for (regi2 in getItems(m_p2x_regi, dim = 1)) {
            for (year2 in getYears(m_p2x_regi)) {
              if (dimSums(v_prodP2XSe[regi2, year2, ], 3) == 0) {
                m_p2x_year[regi2, year2, ] <-
                  1e6 * dimSums(m_p2x_regi[regi2, year2, ] * p_taulength, dim = 3.1) /
                  dimSums(p_taulength, 3) # calculate weighted average (in eur/MWh)
              } else {
                m_p2x_year[regi2, year2, ] <-
                  1e6 * dimSums(m_p2x_regi[regi2, year2, ] * p_taulength * v_prodP2XSe[regi2, year2, ], dim = 3) /
                  dimSums(p_taulength * v_prodP2XSe[regi2, year2, ], 3) # calculate weighted average (in eur/MWh)
              }
            }
          }

        } else {
          m_p2x_year <- 1e6 * m_p2x_regi
        }
      }
      #When there is H2 exchange (constraint at national level)
      m_p2x_agg <- readGDX(gdx, name = c("q_balP2XSe_Agg"),
                           field = "m", format = "first_found", restore_zeros = FALSE,
                           react = 'silent') # [Geur/GWh]
      regi_H2exch <- setdiff(getItems(output, dim = 1), getItems(m_p2x_regi, dim = 1))
      if(!is.null(getItems(m_p2x_agg, dim = 1))) {
        for (year2 in getYears(m_p2x_year)) {
          if(year2 %in% getItems(m_p2x_agg, dim = 2)) {
            m_p2x_year[regi_H2exch,year2,] <- 1e6 * m_p2x_agg[,year2,]
          }
        }
      }

      ## Create magpie to save marginal value to compute required calculations
      o_priceH2_year <- new.magpie(cells_and_regions = getItems(v_prodP2XSe, dim = 1),
                                   years = getYears(v_prodP2XSe), names = NULL,
                                   fill = NA, sort = FALSE, sets = NULL)

      for (t2 in getYears(o_priceH2_year)) {
        if (t2 %in% getYears(m_p2x_year)) {
          o_priceH2_year[, t2, ] <- m_p2x_year[, t2, ] /
            as.numeric(f_npv[getYears(o_priceH2_year) %in% t2]) # [Geur 2010/GWh]
        }
      }

    }

    ##NEWEST VERSION: a single equation for the cases when there is exchange to abroad
    if(c_LIMESversion >= 2.41) {
      m_p2x <- readGDX(gdx, name = c("q_balP2XSe"),
                       field = "m", format = "first_found", restore_zeros = FALSE,
                       react = 'silent') # [Geur/GWh]
      m_p2x <- limesMapping(m_p2x[, , "pehgen"])
      m_p2x_tau <- m_p2x / p_taulength

      ##Estimate prices per tau
      #Discount and convert to EUR/MWh
      ## Create magpie to save marginal value to compute required calculations
      o_priceH2_tau <- new.magpie(cells_and_regions = getItems(v_prodP2XSe, dim = 1),
                                  years = getYears(v_prodP2XSe), names = tau,
                                  fill = NA, sort = FALSE, sets = NULL)

      for (t2 in getYears(o_priceH2_tau)) {
        if (t2 %in% getYears(m_p2x_tau)) {
          o_priceH2_tau[, t2, ] <- m_p2x_tau[, t2, ] * 1e6 /
            as.numeric(f_npv[getYears(o_priceH2_tau) %in% t2])
        }
      }

      #Estimate price per year (undiscounted)
      #Convert to EUR/MWh
      o_priceH2_year <-
        dimSums(o_priceH2_tau * p_taulength * v_prodP2XSe, dim = 3) /
        dimSums(p_taulength * v_prodP2XSe, 3)

    } #end of c_LIMESversion >= 2.41


    #Report annual prices
    tmp1 <- mbind(tmp1, setNames(o_priceH2_year,
                                 "Price|Primary Energy|Hydrogen [electrolysis] (Eur2010/MWh)")) # Convert from Geur/GWh to eur/MWh

    #########################################
    ##PRICES. average prices (external + electrolysers)

    #First version only concerns electricity
    if(c_LIMESversion == 2.36) {

      # Weighted price for hydrogen
      o_pricehgen_weighted <-
        (setNames(output[, , "Price|Primary Energy|Hydrogen [external] (Eur2010/GJ)"], NULL) *
           setNames(tmp1[, , "Primary Energy|Hydrogen [external]|Electricity (TWh/yr)"], NULL) * 3.6 + # Eur/GJ to eur/MWh
           setNames(tmp1[, , "Price|Primary Energy|Hydrogen [electrolysis] (Eur2010/MWh)"], NULL) *
           setNames(tmp1[, , "Primary Energy|Hydrogen [electrolysis]|Electricity (TWh/yr)"], NULL)) /
        (setNames(tmp1[, , "Primary Energy|Hydrogen [external]|Electricity (TWh/yr)"], NULL) +
           setNames(tmp1[, , "Primary Energy|Hydrogen [electrolysis]|Electricity (TWh/yr)"], NULL))
      tmp1 <- mbind(tmp1, setNames(o_pricehgen_weighted, "Price|Primary Energy|Hydrogen (Eur2010/MWh)"))

    }

    #Versions 2.37-2.4 consider imports at an exogenous cost
    if (c_LIMESversion >= 2.37 & c_LIMESversion <= 2.40) {

      # Weighted price for hydrogen
      o_pricehgen_weighted <-
        (setNames(output[, , "Price|Primary Energy|Hydrogen [external] (Eur2010/GJ)"], NULL) *
           setNames(tmp1[, , "Primary Energy|Hydrogen [external] (TWh/yr)"], NULL) * 3.6 + # Eur/GJ to eur/MWh
           setNames(tmp1[, , "Price|Primary Energy|Hydrogen [electrolysis] (Eur2010/MWh)"], NULL) *
           setNames(tmp1[, , "Primary Energy|Hydrogen [electrolysis] (TWh/yr)"], NULL)) /
        setNames(tmp1[, , "Primary Energy|Hydrogen (TWh/yr)"], NULL)
      tmp1 <- mbind(tmp1, setNames(o_pricehgen_weighted, "Price|Primary Energy|Hydrogen (Eur2010/MWh)"))

    }


    #End of if c_LIMESversion >= 2.36
  }

  tmp <- mbind(tmp,tmp1)

  return(tmp)
}
