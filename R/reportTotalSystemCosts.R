#' Read in GDX and calculate electricity generation, used in convGDX2MIF.R for the reporting
#'
#' Read in electricity generation data from GDX file, information used in convGDX2MIF.R
#' for the reporting
#'
#'
#' @param gdx a GDX object as created by readGDX, or the path to a gdx
#' @param output a magpie object containing all needed variables generated by other report*.R functions
#' @return MAgPIE object - contains the Generation variables
#' @author Sebastian Osorio, Renato Rodrigues
#' @seealso \code{\link{convGDX2MIF}}
#' @examples
#'
#' \dontrun{reportTotalSystemCosts(gdx)}
#'
#' @importFrom gdx readGDX
#' @importFrom magclass mbind setNames dimSums getSets getSets<- as.magpie getItems
#' @export
#'
reportTotalSystemCosts <- function(gdx,output=NULL) {

  if(is.null(output)){
    stop("please provide a file containing all needed information")
  }

  # read parameters and sets
  ter <- readGDX(gdx,name="ter") #set of variable renewable electricity generation technologies
  ternofluc <- readGDX(gdx,name="ternofluc") #set of non-variable (non-fluctuating) renewable electricity generation technologies
  c_esmdisrate <- readGDX(gdx,name="c_esmdisrate",field="l",format="first_found") #interest rate
  p_ts <- readGDX(gdx,name="p_ts",field="l",format="first_found") #time step
  trans <- readGDX(gdx,name="trans") #set of cross-border transmission lines (numeric)
  regi <- readGDX(gdx,name="regi") #set of countries
  p_incoall <- readGDX(gdx,name="p_incoall",field="l",format="first_found") #capital costs

  # read variables
  v_costfu <- readGDX(gdx,name="v_costfu",field="l",format="first_found")
  v_costom <- readGDX(gdx,name="v_costom",field="l",format="first_found")
  v_costin <- readGDX(gdx,name="v_costin",field="l",format="first_found")
  v_deltacap <- readGDX(gdx,name="v_deltacap",field="l",format="first_found")
  v_costintrans <- readGDX(gdx,name="v_costintrans",field="l",format="first_found")
  if(is.null(getNames(v_costintrans))) { #Sets of v_costintrans changed and are not per conn anymore, so we included an additional variable in LIMES, but keep if working for the previous one
    o_costintrans <- readGDX(gdx,name="o_costintrans",field="l",format="first_found")
  } else {
    o_costintrans <- v_costintrans
  }

  # read variables that have been already calculated in other functions
  o_costtrade <- output[,,"Total Energy System Cost|Power Sector|Trade Costs (billion eur2010/yr)"] #From Exchange
  o_costco2 <- output[,,"Total Energy System Cost|Power Sector|CO2 costs (billion eur2010/yr)"] #From CO2Price

  # create MagPie object of variables with iso3 regions
  v_costfu <- limesMapping(v_costfu)
  v_costom <- limesMapping(v_costom)
  v_costin <- limesMapping(v_costin)
  v_deltacap <- limesMapping(v_deltacap)
  p_incoall <- limesMapping(p_incoall)

  #FUEL COSTS
  tmp1 <- NULL
  tmp1 <- mbind(tmp1,setNames(v_costfu,"Total Energy System Cost|Power Sector|Fuel Costs (billion eur2010/yr)"))

  #O&M COSTS
  tmp1 <- mbind(tmp1,setNames(v_costom,"Total Energy System Cost|Power Sector|O&M Costs (billion eur2010/yr)"))

  #COST OF EMISSIONS
  #See reportCO2Price

  #GENERATION INVESTMENT COSTS
  tmp1 <- mbind(tmp1,setNames(v_costin,"Total Energy System Cost|Power Sector|Generation Investment Costs (billion eur2010/yr)"))

  #Specific calculation for RES
  t_all <- getYears(v_costfu)
  costin_tech <- new.magpie(cells_and_regions = getItems(p_incoall, dim = 1), years = t_all, names = getNames(p_incoall),
                fill = 0, sort = FALSE, sets = NULL)
  for (t2 in t_all) {
    costin_tech[,t2,] <- v_deltacap[,t2,]*p_incoall[,t2,]
  }
  tmp1 <- mbind(tmp1,setNames(dimSums(costin_tech[,,c(ter,ternofluc)],dim=3),"Total Energy System Cost|Power Sector|Generation Investment Costs|Renewable (billion eur2010/yr)"))


  #TRANSMISSION INVESTMENT COSTS
  o_costintrans_regi <- NULL
  #estimate aggregated (total) exports from each country
  for (regi2 in regi) {

    #aggregate the positive flows
    conns1 <- trans[which(trans$regi == regi2),]$conn
    if(sum(as.numeric(conns1))==0) {
      cost1<-0
    } else {
      cost1<-0
      for (conns_tmp in conns1) {
        cost1 <- cost1 + setNames(o_costintrans[,,conns_tmp]/2,NULL)
      }
    }

    #aggreate negative flows
    conns2 <- trans[which(trans$reg == regi2),]$conn
    if(sum(as.numeric(conns2))==0) {
      cost2<-0
    } else {
      cost2<-0
      for (conns_tmp in conns2) {
        cost2 <- cost2 + setNames(o_costintrans[,,conns_tmp]/2,NULL)
      }
    }
    #sum positive and negative flows
    cost <- cost1 + cost2
    #add country to the names
    getNames(cost)<-regi2
    #concatenate data from different countries (regi)
    o_costintrans_regi <- mbind(o_costintrans_regi,cost)
  }

  # create MagPie object of exports volume and transmission capacity with iso3 regions
  o_costintrans_regi <- limesMapping(o_costintrans_regi)
  #investment costs (assuming they are allocated by half to each country)
  tmp1 <- mbind(tmp1,setNames(o_costintrans_regi,"Total Energy System Cost|Power Sector|Transmission Investment Costs (billion eur2010/yr)"))

  #TOTAL SYSTEM COSTS
  tmp2 <- NULL
  tmp2 <- mbind(tmp2,setNames(v_costfu + v_costom + v_costin + o_costintrans_regi,"Total Energy System Cost|Power Sector|w/o trade and w/o CO2 costs (billion eur2010/yr)"))
  tmp2 <- mbind(tmp2,setNames(v_costfu + v_costom + v_costin + o_costintrans_regi + o_costtrade,"Total Energy System Cost|Power Sector|w/ trade and w/o CO2 costs (billion eur2010/yr)"))
  tmp2 <- mbind(tmp2,setNames(v_costfu + v_costom + v_costin + o_costintrans_regi + o_costtrade + o_costco2,"Total Energy System Cost|Power Sector|w/ trade and w/ CO2 costs (billion eur2010/yr)"))
  tmp2 <- mbind(tmp2,setNames(v_costfu + v_costom + v_costin + o_costintrans_regi + o_costco2,"Total Energy System Cost|Power Sector|w/o trade and w/ CO2 costs (billion eur2010/yr)"))


  # concatenating costs
  tmp <- mbind(tmp1,tmp2)

  #there is no need to discount the future costs. All monetary values are in real EUR, so there is no need for deflation.
  #Only for the objective function, we need to discount the future costs with the discount rate to represent the effect of GDP growth
  #and pure rate of time preference (or simple WACC/financing questions), but when we talk about the yearly monetary flows in a certain year,
  #these values should not be discounted.

  return(tmp)
}

